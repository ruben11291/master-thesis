# **********************************************************************
#
# Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.4.2
#
# <auto-generated>
#
# Generated from file `Geocloud.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy, __builtin__

# Start of module geocloud
_M_geocloud = Ice.openModule('geocloud')
__name__ = 'geocloud'

if not _M_geocloud.__dict__.has_key('Log'):
    _M_geocloud.Log = Ice.createTempClass()
    class Log(Ice.Object):
        def __init__(self):
            if __builtin__.type(self) == _M_geocloud.Log:
                raise RuntimeError('geocloud.Log is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::geocloud::Log')

        def ice_id(self, current=None):
            return '::geocloud::Log'

        def ice_staticId():
            return '::geocloud::Log'
        ice_staticId = staticmethod(ice_staticId)

        def getLastModified(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_geocloud._t_Log)

        __repr__ = __str__

    _M_geocloud.LogPrx = Ice.createTempClass()
    class LogPrx(Ice.ObjectPrx):

        def getLastModified(self, _ctx=None):
            return _M_geocloud.Log._op_getLastModified.invoke(self, ((), _ctx))

        def begin_getLastModified(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Log._op_getLastModified.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_getLastModified(self, _r):
            return _M_geocloud.Log._op_getLastModified.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_geocloud.LogPrx.ice_checkedCast(proxy, '::geocloud::Log', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_geocloud.LogPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_geocloud._t_LogPrx = IcePy.defineProxy('::geocloud::Log', LogPrx)

    _M_geocloud._t_Log = IcePy.defineClass('::geocloud::Log', Log, (), True, None, (), ())
    Log._ice_type = _M_geocloud._t_Log

    Log._op_getLastModified = IcePy.Operation('getLastModified', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (), (), IcePy._t_string, ())

    _M_geocloud.Log = Log
    del Log

    _M_geocloud.LogPrx = LogPrx
    del LogPrx

if not _M_geocloud.__dict__.has_key('Processor'):
    _M_geocloud.Processor = Ice.createTempClass()
    class Processor(_M_geocloud.Log):
        def __init__(self):
            if __builtin__.type(self) == _M_geocloud.Processor:
                raise RuntimeError('geocloud.Processor is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::geocloud::Log', '::geocloud::Processor')

        def ice_id(self, current=None):
            return '::geocloud::Processor'

        def ice_staticId():
            return '::geocloud::Processor'
        ice_staticId = staticmethod(ice_staticId)

        def l0(self, path, current=None):
            pass

        def l0r(self, path, current=None):
            pass

        def l1a(self, path, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_geocloud._t_Processor)

        __repr__ = __str__

    _M_geocloud.ProcessorPrx = Ice.createTempClass()
    class ProcessorPrx(_M_geocloud.LogPrx):

        def l0(self, path, _ctx=None):
            return _M_geocloud.Processor._op_l0.invoke(self, ((path, ), _ctx))

        def begin_l0(self, path, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Processor._op_l0.begin(self, ((path, ), _response, _ex, _sent, _ctx))

        def end_l0(self, _r):
            return _M_geocloud.Processor._op_l0.end(self, _r)

        def l0r(self, path, _ctx=None):
            return _M_geocloud.Processor._op_l0r.invoke(self, ((path, ), _ctx))

        def begin_l0r(self, path, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Processor._op_l0r.begin(self, ((path, ), _response, _ex, _sent, _ctx))

        def end_l0r(self, _r):
            return _M_geocloud.Processor._op_l0r.end(self, _r)

        def l1a(self, path, _ctx=None):
            return _M_geocloud.Processor._op_l1a.invoke(self, ((path, ), _ctx))

        def begin_l1a(self, path, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Processor._op_l1a.begin(self, ((path, ), _response, _ex, _sent, _ctx))

        def end_l1a(self, _r):
            return _M_geocloud.Processor._op_l1a.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_geocloud.ProcessorPrx.ice_checkedCast(proxy, '::geocloud::Processor', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_geocloud.ProcessorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_geocloud._t_ProcessorPrx = IcePy.defineProxy('::geocloud::Processor', ProcessorPrx)

    _M_geocloud._t_Processor = IcePy.defineClass('::geocloud::Processor', Processor, (), True, None, (_M_geocloud._t_Log,), ())
    Processor._ice_type = _M_geocloud._t_Processor

    Processor._op_l0 = IcePy.Operation('l0', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())
    Processor._op_l0r = IcePy.Operation('l0r', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())
    Processor._op_l1a = IcePy.Operation('l1a', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())

    _M_geocloud.Processor = Processor
    del Processor

    _M_geocloud.ProcessorPrx = ProcessorPrx
    del ProcessorPrx

if not _M_geocloud.__dict__.has_key('Orchestrator'):
    _M_geocloud.Orchestrator = Ice.createTempClass()
    class Orchestrator(_M_geocloud.Log):
        def __init__(self):
            if __builtin__.type(self) == _M_geocloud.Orchestrator:
                raise RuntimeError('geocloud.Orchestrator is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::geocloud::Log', '::geocloud::Orchestrator')

        def ice_id(self, current=None):
            return '::geocloud::Orchestrator'

        def ice_staticId():
            return '::geocloud::Orchestrator'
        ice_staticId = staticmethod(ice_staticId)

        def downloadedImage(self, path, current=None):
            pass

        def levelProcessed(self, path, level, current=None):
            pass

        def imageProcessed(self, path, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_geocloud._t_Orchestrator)

        __repr__ = __str__

    _M_geocloud.OrchestratorPrx = Ice.createTempClass()
    class OrchestratorPrx(_M_geocloud.LogPrx):

        def downloadedImage(self, path, _ctx=None):
            return _M_geocloud.Orchestrator._op_downloadedImage.invoke(self, ((path, ), _ctx))

        def begin_downloadedImage(self, path, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Orchestrator._op_downloadedImage.begin(self, ((path, ), _response, _ex, _sent, _ctx))

        def end_downloadedImage(self, _r):
            return _M_geocloud.Orchestrator._op_downloadedImage.end(self, _r)

        def levelProcessed(self, path, level, _ctx=None):
            return _M_geocloud.Orchestrator._op_levelProcessed.invoke(self, ((path, level), _ctx))

        def begin_levelProcessed(self, path, level, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Orchestrator._op_levelProcessed.begin(self, ((path, level), _response, _ex, _sent, _ctx))

        def end_levelProcessed(self, _r):
            return _M_geocloud.Orchestrator._op_levelProcessed.end(self, _r)

        def imageProcessed(self, path, _ctx=None):
            return _M_geocloud.Orchestrator._op_imageProcessed.invoke(self, ((path, ), _ctx))

        def begin_imageProcessed(self, path, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.Orchestrator._op_imageProcessed.begin(self, ((path, ), _response, _ex, _sent, _ctx))

        def end_imageProcessed(self, _r):
            return _M_geocloud.Orchestrator._op_imageProcessed.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_geocloud.OrchestratorPrx.ice_checkedCast(proxy, '::geocloud::Orchestrator', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_geocloud.OrchestratorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_geocloud._t_OrchestratorPrx = IcePy.defineProxy('::geocloud::Orchestrator', OrchestratorPrx)

    _M_geocloud._t_Orchestrator = IcePy.defineClass('::geocloud::Orchestrator', Orchestrator, (), True, None, (_M_geocloud._t_Log,), ())
    Orchestrator._ice_type = _M_geocloud._t_Orchestrator

    Orchestrator._op_downloadedImage = IcePy.Operation('downloadedImage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())
    Orchestrator._op_levelProcessed = IcePy.Operation('levelProcessed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string), ((), IcePy._t_string)), (), IcePy._t_int, ())
    Orchestrator._op_imageProcessed = IcePy.Operation('imageProcessed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())

    _M_geocloud.Orchestrator = Orchestrator
    del Orchestrator

    _M_geocloud.OrchestratorPrx = OrchestratorPrx
    del OrchestratorPrx

if not _M_geocloud.__dict__.has_key('ArchiveAndCataloge'):
    _M_geocloud.ArchiveAndCataloge = Ice.createTempClass()
    class ArchiveAndCataloge(_M_geocloud.Log):
        def __init__(self):
            if __builtin__.type(self) == _M_geocloud.ArchiveAndCataloge:
                raise RuntimeError('geocloud.ArchiveAndCataloge is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::geocloud::ArchiveAndCataloge', '::geocloud::Log')

        def ice_id(self, current=None):
            return '::geocloud::ArchiveAndCataloge'

        def ice_staticId():
            return '::geocloud::ArchiveAndCataloge'
        ice_staticId = staticmethod(ice_staticId)

        def createScenario(self, scenario, current=None):
            pass

        def catalogue(self, path, scenario, current=None):
            pass

        def deleteScenario(self, scenario, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_geocloud._t_ArchiveAndCataloge)

        __repr__ = __str__

    _M_geocloud.ArchiveAndCatalogePrx = Ice.createTempClass()
    class ArchiveAndCatalogePrx(_M_geocloud.LogPrx):

        def createScenario(self, scenario, _ctx=None):
            return _M_geocloud.ArchiveAndCataloge._op_createScenario.invoke(self, ((scenario, ), _ctx))

        def begin_createScenario(self, scenario, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.ArchiveAndCataloge._op_createScenario.begin(self, ((scenario, ), _response, _ex, _sent, _ctx))

        def end_createScenario(self, _r):
            return _M_geocloud.ArchiveAndCataloge._op_createScenario.end(self, _r)

        def catalogue(self, path, scenario, _ctx=None):
            return _M_geocloud.ArchiveAndCataloge._op_catalogue.invoke(self, ((path, scenario), _ctx))

        def begin_catalogue(self, path, scenario, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.ArchiveAndCataloge._op_catalogue.begin(self, ((path, scenario), _response, _ex, _sent, _ctx))

        def end_catalogue(self, _r):
            return _M_geocloud.ArchiveAndCataloge._op_catalogue.end(self, _r)

        def deleteScenario(self, scenario, _ctx=None):
            return _M_geocloud.ArchiveAndCataloge._op_deleteScenario.invoke(self, ((scenario, ), _ctx))

        def begin_deleteScenario(self, scenario, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_geocloud.ArchiveAndCataloge._op_deleteScenario.begin(self, ((scenario, ), _response, _ex, _sent, _ctx))

        def end_deleteScenario(self, _r):
            return _M_geocloud.ArchiveAndCataloge._op_deleteScenario.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_geocloud.ArchiveAndCatalogePrx.ice_checkedCast(proxy, '::geocloud::ArchiveAndCataloge', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_geocloud.ArchiveAndCatalogePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_geocloud._t_ArchiveAndCatalogePrx = IcePy.defineProxy('::geocloud::ArchiveAndCataloge', ArchiveAndCatalogePrx)

    _M_geocloud._t_ArchiveAndCataloge = IcePy.defineClass('::geocloud::ArchiveAndCataloge', ArchiveAndCataloge, (), True, None, (_M_geocloud._t_Log,), ())
    ArchiveAndCataloge._ice_type = _M_geocloud._t_ArchiveAndCataloge

    ArchiveAndCataloge._op_createScenario = IcePy.Operation('createScenario', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())
    ArchiveAndCataloge._op_catalogue = IcePy.Operation('catalogue', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string), ((), IcePy._t_string)), (), IcePy._t_int, ())
    ArchiveAndCataloge._op_deleteScenario = IcePy.Operation('deleteScenario', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string),), (), IcePy._t_int, ())

    _M_geocloud.ArchiveAndCataloge = ArchiveAndCataloge
    del ArchiveAndCataloge

    _M_geocloud.ArchiveAndCatalogePrx = ArchiveAndCatalogePrx
    del ArchiveAndCatalogePrx

# End of module geocloud
