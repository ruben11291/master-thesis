\section{Introducción}
\label{sec:intro}

Las compañías dedicadas a la observación de la Tierra (EO industries) implementan la adquisición, almacenamiento, procesamiento y distribución de las imágenes captadas, en su propias granjas de servidores. Sin embargo estas soluciones tienen riesgos ligados a esa infraestructura. Por ejemplo, la escalabilidad. Puede ser que en un momento crítico, se demanden más recursos y esa infraestructura no puede procesar todas las peticiones.

En los últimos años, se ha puesto de moda hablar de \emph{Cloud Computing}. Este concepto se basa en el concepto de procesamiento distribuido. Esto no es ni más ni menos que unificar granjas de servidores para unificar recursos tanto de proceso como de almacenamiento, de forma transparente al usario.

El consorcio europeo Fed4FIRE \cite{F4F} proporciona una serie de \emph{Testbeds} para el desarrollo de distintas investigaciones. Estas herramientas han sido el resultado de varios proyectos europeos y los que cabe destacar bajo el punto de vista de este proyecto son los siguientes:
\begin{itemize}
\item \emph{PlanetLab Europe:}


\end{itemize}

La observación de la Tierra ha sido siempre y será uno de los sectores más
Actualmente, uno de los sectores de la informática que más se ha desarrollado ha sido
la computación gráfica. Esto es debido a que no solamente ha formado parte de la comunidad
científica, si no que ha invadido diversos mercados. Entre estos, se encuentran  la visualización médica, el avance de los videojuegos, las cinematográficas y al potente hardware donde desarrollarse.
Sobre todo el negocio cinematográfico y de videojuegos están consiguiendo que
las técnicas de computación gráfica avancen más rápidamente.

El proceso de construcción de una escena 3D cuenta con una
serie de etapas principales que pueden resumirse como:

\begin{itemize}
\item \emph{Modelado:} Construcción de la escena representando los objetos con diversas técnicas,
ya sean mallas poligonales, superficies NURBS, superficies implícitas, etc...
\item \emph{Asignación de materiales:} Cada objeto tiene unas propiedades y comportamientos respecto
a como refleja la luz incidente, como el modelo de sombreado empleado, la textura, color o índice de refracción.
\item\emph {Iluminación:}En esta fase se definen las luces de la escena.
\item\emph {Fase de rendering:} Dependiendo del nivel de realismo con el que se simule el comportamiento físico de la luz, tenemos diferentes familias de métodos de rendering como los basados en RayCasting, RayTracing, PathTracing, etc...
\end {itemize}


\subsection{Rendering}
\label{sec:rendering}

Antes se mencionó que el último paso para representar una escena 3D como una imagen 2D se denomina rendering. A continuación se explicarán algunos de los algoritmos más
usados en este proceso, pero antes se definirán varios conceptos básicos\cite{ground_up} para facilitar su comprensión.
\begin{itemize}
\item\emph{Plano de vista:} Matriz de píxeles, la cual coincide con el límite de la escena que el observador es capaz de ver desde su posición.
\item\emph{Punto de vista:} Situación del observador.
\end{itemize}

Existen diversos algoritmos con esta finalidad, cada uno con sus ventajas e inconvenientes\cite{real-time}. Estos son \emph{RayCasting}, \emph{RayTracing} y
\emph{PathTracing} y básicamente realizan el proceso de render de esta foma:
\begin{itemize}
\item\emph{RayCasting:} Consiste en lanzar rayos desde el plano de vista, uno por cada píxel, y encontrar el punto de intersección
más cercano con los objetos de la escena. Su eficiencia es bastante aceptable pero genera resultados con poca calidad debido a que no simula efectos de rebote de la luz entre superficies.
\item\emph{RayTracing:} Es un método elegante  y sencillo que permite calcular de una forma unificada la reflexión y refracción de la luz,
sombras, eliminación de objetos ocultos entre otras características. Existen dos aproximaciones para la implementación de este algoritmo. La primera alternativa se basa en lanzar rayos desde las fuentes emisoras de luz y seguir el camino desde estas hasta el punto de vista (\emph{forward RayTracing}).
La otra versión del algoritmo (\emph{backward RayTracing}) donde los rayos parten del plano de imagen y alcanzan a los objetos de la escena.  Este método evita trazar
inútilmente rayos que en el caso de que se lanzaran desde las fuentes de luz, muchos no llegarían al plano de vista y por lo tanto no representarían nada, únicamente consumiendo recursos computacionales.
\item\emph{PathTracing:} Lanza rayos aleatorios para simular sombras suaves, motion blur  y profundidad de campo. Este algoritmo calcula todos los posibles caminos
de luz, por lo que consigue un resultado muy realista, pero es muy costoso computacionalmente.
\end{itemize}

% \subsection{Multimodal Rendering}
%
% El desarrollo de numerosas aplicaciones en los diversos campos de la ciencia han incrementado la demanda de sistemas de visualización multimodal. Estos sistemas son capaces
% de renderizar simultáneamente varias propiedades en la misma región 3D

\subsection{Problemática}
\label{sec:problematica}

% \href{}
Como se ha podido observar, existen limitaciones importantes a la hora de renderizar. El primero es debido
al gran coste computacional. Como se ha mencionado anteriormente, los rayos se refractan, reflejan en los distintos objetos,
cada uno de ellos con distintas propiedades. Con lo cual, el comportamiento del rayo no está para nada determinado y puede
ser complejo estudiar su comportamiento. Las escenas que se quieren renderizar a un nivel de detalle realista y son
muy complejas, requieren varias horas de render. Incluso si este proceso se realiza en un \emph{cluster} muy potente
y con la última tecnología en redes de altas prestaciones, se requiere un tiempo de cómputo muy alto. Estas condiciones no son permisibles, por ejemplo en algunos casos de diagnóstico por imagen, cuando la imagen se tiene que ir procesando a tiempo real.

En torno a eso, se tiene el problema de que en una imagen existen diversas zonas de distinta complejidad. Estas partes se podrían renderizar usando diferentes algoritmos sin perder demasiada información visual\cite{magarro}. Con este planteamiento,  surge el problema de la división de tareas y asignación balanceada a los distintos nodos procesadores. Con lo cual, se podría dividir esa escena respecto a la complejidad de cada partición
y a cada una se le asignaría un algoritmo de render para conseguir ganar en eficiencia sin perder calidad en el resultado.

Relacionado con el cálculo de la complejidad de las distintas zonas de la imagen, se plantean diferentes enfoques. Estos pueden ser por ejemplo
las distintas fuentes de luz de la escena, la cantidad de caras de los objetos, la distancia a la que están del plano de vista y si será conveniente o no
aplicarle un tipo de renderizado más óptimo si apenas se percibirá, como también el renderizar algún objeto que desde el punto de vista del observador
no será visible.






% Local Variables:
%   coding: utf-8
%   fill-column: 90
%   mode: flyspell
%   ispell-local-dictionary: "castellano"
%   mode: latex
%   TeX-master: "main"
% End:
